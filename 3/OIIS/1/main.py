import numpy as np
import matplotlib.pyplot as plt

# --- Шаг 1: Создание входного сигнала (синусоида) ---

# Параметры сигнала
N = 1024              # Количество точек (сэмплов). Для БПФ лучше брать степени двойки (64, 128, 256, 1024...).
FREQUENCY = 5         # Частота синусоиды в Гц. Это значит 5 полных колебаний в секунду.
SAMPLING_RATE = 100   # Частота дискретизации в Гц (сколько раз в секунду мы измеряем сигнал).
                      # Должна быть как минимум в 2 раза больше FREQUENCY (Теорема Котельникова).

# Создаем временную шкалу от 0 до N/SAMPLING_RATE секунд.
# np.linspace создает массив равномерно распределенных чисел.
x = np.linspace(0.0, N / SAMPLING_RATE, N, endpoint=False)

# Генерируем саму функцию синуса
# y = A * sin(2 * pi * f * t)
y = np.sin(2 * np.pi * FREQUENCY * x)


# --- Шаг 2: Применение БПФ ---

# np.fft.fft() - это и есть функция Быстрого преобразования Фурье
yf = np.fft.fft(y)

# Результат БПФ - это массив комплексных чисел. Чтобы получить амплитудный спектр,
# нужно взять модуль от каждого числа и нормализовать его.
# Делим на N/2, чтобы амплитуда пика соответствовала амплитуде исходного сигнала (которая у нас = 1).
amplitude_spectrum = 2.0/N * np.abs(yf[:N//2])

# Создаем шкалу частот для оси X графика спектра
xf = np.fft.fftfreq(N, 1 / SAMPLING_RATE)[:N//2]


# --- Шаг 3: Визуализация и проверка результата ---

# Создаем окно с двумя графиками
plt.figure(figsize=(12, 6))

# Первый график: наш исходный сигнал
plt.subplot(2, 1, 1)
plt.plot(x, y)
plt.title('Исходный сигнал: sin(x)')
plt.xlabel('Время (с)')
plt.ylabel('Амплитуда')
plt.grid()

# Второй график: результат БПФ (амплитудный спектр)
plt.subplot(2, 1, 2)
plt.plot(xf, amplitude_spectrum)
plt.title('Амплитудный спектр после БПФ')
plt.xlabel('Частота (Гц)')
plt.ylabel('Амплитуда')
plt.grid()

# Показать оба графика
plt.tight_layout()
plt.show()